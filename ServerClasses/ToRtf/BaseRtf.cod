
class "Базовый класс для работы с шаблоном RTF"; --  replacement in the template RTF
-- Пример выгрузки в файл без повторяющихся секций
-- with CTUL.ToRtf.BaseRtf.New(['Имя Банка','Расчетный счет']) do
--   Tpl = 'Содержимое шаблона файла rtf';
--   TplReplaceFrom = ['{##Банк.Name#}','{##Банк.AccountNum#}'];
--   ToRtfFile('c:\temp\File.rtf');
-- od;


--import SConsole; -- для использование trace и message в режиме студии для серверных классов
inclass
  type tArrayV = Variant[];
  type FuncS2S = func(s :string):string;



  func CreateEx synonym new (aTplReplaceTo :Variant[] = nil) :ToRtf.BaseRtf;
    result = Create;
    result.TplReplaceTo = aTplReplaceTo;
  end;

  func CreateByRecord (aRec :Record) :ToRtf.BaseRtf;
    result = CreateEx(TplReplaceToFromRecord(aRec));
    result.Internal = aRec;
  end;

  #help `Получаем из aRec массив данных для подстановок
         Перекрывается в наследниках`;
  func TplReplaceToFromRecord(aRec :Record) :Variant[];
  end;

  #help `Получаем итоговое содержимое файла rtf`;
  func TplToRtf(aTplReplaceTo :Variant; aTpl :String = Tpl; aTplReplaceFrom :String[] = TplReplaceFrom) :String;
    if aTplReplaceTo is String[]:
      Result = ReplaceStrings(aTpl, aTplReplaceFrom, aTplReplaceTo as String[], True, False);
    else
      var vTplReplaceTo :String[];
      for var j = 1..LengthOfArray(tArrayV(aTplReplaceTo)) do
        if tArrayV(aTplReplaceTo)[j] is FuncS2S:
          vTplReplaceTo[j] = FuncS2S(tArrayV(aTplReplaceTo)[j])(aTplReplaceFrom[j]);
        else
          vTplReplaceTo[j] = tArrayV(aTplReplaceTo)[j] as String;
        fi;
      od;
      Result = ReplaceStrings(aTpl, aTplReplaceFrom, vTplReplaceTo, True, False);
    fi;
  end;

  func TplToRtf64(aTplReplaceTo :Variant[]; aTpl :String = Tpl; aTplReplaceFrom :String[] = TplReplaceFrom; Encoding :Variant = '1251') :String;
    Result = StringToBinaryObject(TplToRtf(aTplReplaceTo, aTpl, aTplReplaceFrom), Encoding).AsBase64;
  end;


  #help `шаблон - содержимое файла rtf
         с закодированным списком замен
         Перекрывается в наследниках`;
  var Tpl :string;

  #help `список замен для Tpl - перекрывается в наследниках
         (куски текста, которые будем менять на реальные данные)`;
  var TplReplaceFrom :String[];

  func StringToBinaryObject(aFrom :String; Encoding :Variant = TextFile.UTF8) :BinaryObject;
    Result = BinaryObject.Create;
    if Encoding is String and Encoding as String = '1251' :
      Result.SetString(aFrom, 1251); --??? непонятно почему, но нормально не работает Encoding как Variant ???
    else
      Result.SetString(aFrom, Encoding);
    fi;
  end;

  func String64ToBinaryObject(aFrom :String) :BinaryObject;
    Result = BinaryObject.Create;
    Result.AsBase64 = aFrom;
  end;


  Func GetPar(ш,в,лп,пп,вп,нп :Integer) :String;
    Result = '\paperw'+str(56.7*ш,0)+'\paperh'+str(56.7*в,0)+'\margl'+str(56.7*лп,0)+'\margr'+str(56.7*пп,0)+'\margt'+str(56.7*вп,0)+'\margb'+str(56.7*нп,0);
  end;

  Func GetParA3(landscape:Logical; лп,пп,вп,нп :Integer) :String;
    if landscape: Result = GetPar(420,297,лп,пп,вп,нп)+'\landscape';
    else Result = GetPar(297,420,лп,пп,вп,нп);
    fi;
  end;

  Func GetParA4(landscape:Logical; лп,пп,вп,нп :Integer) :String;
    if landscape: Result = GetPar(297,210,лп,пп,вп,нп)+'\landscape';
    else Result = GetPar(210,297,лп,пп,вп,нп);
    fi;
  end;

  Func GetParA4M(landscape:Logical; лп,пп,вп,нп :Integer; масштаб :Numeric) :String;
    -- минимальный масштаб=53.2258%,т.к. максимальная ширина листа=558мм
    -- при уменьшении масштаба происходит пропорциональное увеличение размеров листа
    var k :Numeric;
    масштаб = max([53.2258, масштаб]);
    k = 100/масштаб;
    if landscape: Result = GetPar(int(297*k),int(210*k),int(лп*k),int(пп*k),int(вп*k),int(нп*k))+'\landscape';
    else Result = GetPar(int(210*k),int(297*k),int(лп*k),int(пп*k),int(вп*k),int(нп*k));
    fi;
  end;

  Func GetParBytwip(twip,лп,пп,вп,нп :Integer) :String;
    var w,mm :Integer;
    w = лп+пп;
    mm = int(trunc(twip/56.7));
    if 210-w >= mm: Result = GetParA4(false,лп,пп,вп,нп);
    elsif 297-w >= mm: Result = GetParA4(true,лп,пп,вп,нп);
    else Result = GetPar(mm+w,210,лп,пп,вп,нп);
    fi;
  end;
  --^jpeg2rtfScaleCrop(nfile_rtf,file_jpeg,100,100,0,0,0,0,'',0);
  func jpeg2rtfScaleCrop(file_jpeg:String; scaleW:Numeric = 100; scaleH:Numeric = 100; cropT:Integer = 0; cropB:Integer = 0; cropL:Integer = 0; cropR:Integer = 0; brdr:String = ''; Align:Integer = 0 ):String;-- вставляет в файл rtf с номером nfile_rtf в текущую позицию картинку из файла file_jpeg
  --2scaleW0<0 => abs(scaleW) как ширина
  --2scaleW0>0 => abs(scaleW) как % к ширине (от 1% до 100% )
  --2scaleH0<0 => abs(scaleH) как высота
  --2scaleH0>0 => abs(scaleH) как % к высоте (от 1% до 100% )
  --2brdr0=
  --'s'   : определяет простую рамку для рисунка
  --'db'  : определяет двойную рамку для рисунка.
  --'th'  : определяет жирную линию для рамки рисунка.
  --'sh'  : определяет затененную рамку для рисунка
  --'dot' : определяет для рисунка пунктирную линию.
  --'hair': определяет тонкую линию для рамки рисунка.
--  var jpg,FileData:AutoObject;
  var jpg :image;
  var Width, Height: Integer;
  var w, h:Numeric;
  var frmt:String;
   if not existfile(file_jpeg): return; fi;
   jpg = Image.Create;--jpg=AutoObject.Create("WIA.ImageFile");
--field Handle :Pointer
--field Format :String
   Try
    jpg.LoadFromFile(file_jpeg);-- jpg.LoadFile(file_jpeg);
    Width  = jpg.Width;
    Height = jpg.Height;
  --  HRes   = AsInteger(jpg.HorizontalResolution);
  --  VRes   = AsInteger(jpg.VerticalResolution);
  --  PDepth = AsInteger(jpg.PixelDepth);
    W = Width;
    H = Height;
    if match(file_jpeg,'*.emf'):
       frmt='{\pict\emfblip\picw%d\pich%d\picwgoal%d\pichgoal%d';
    else
       frmt='{\pict\jpegblip\picw%d\pich%d\picwgoal%d\pichgoal%d';
    fi;
    if scaleW<0: W=-scaleW; scaleW=100; fi;
    if scaleH<0: H=-scaleH; scaleH=100; fi;
    Result = Sys.Strings.Format(frmt, [Width, Height, int(56.7*W), int(56.7*H), int(scaleW), int(scaleH)]);
    if scaleW<>100:
       frmt=frmt+'\picscalex'+str(scaleW);
    fi;
    if scaleH<>100:
       frmt=frmt+'\picscaley'+str(scaleH);
    fi;
    Result = Sys.Strings.Format(frmt, [int(56.7*cropT) ,int(56.7*cropB) ,int(56.7*cropL) ,int(56.7*cropR)]);

    if cropT+cropB+cropL+cropR>0:
       frmt=frmt+'\piccropt%d\piccropb%d\piccropl%d\piccropr%d';
       Result = Result + Sys.Strings.Format(frmt, [int(56.7*cropT) ,int(56.7*cropB) ,int(56.7*cropL) ,int(56.7*cropR)]);
    fi;
    if brdr<>'':
       Result = Result + '\brdr'+brdr;
    fi;
--    frmt=frmt+' ';
--    Result = Sys.Strings.Format(frmt, [Width, Height, int(56.7*W), int(56.7*H), int(scaleW), int(scaleH) ,int(56.7*cropT) ,int(56.7*cropB) ,int(56.7*cropL) ,int(56.7*cropR)]);
    Result = Result +' '+ jpg.AsHex;--  res=ExecuteFuncL('Раб.WSH.File2FileHex',file_jpeg,'',nfile_rtf);
  --  FileData = AsAutoObject(jpg.FileData); --Vector
  --  count=AsInteger(FileData.count);
  --  for j=1..count do
  --   v=AsInteger(FileData.item[j]);
  --   TextFileAppendLn(nfile_rtf, str16(v,2));
  --  od;
    if Align=0: Result = Result + '}\ql\par';
    elsif Align=1: Result = Result + '}\qr\par';
    else Result = Result + '}\qc\par';
    fi;
   except
    raise;
   end;
  end;


inobject public


  #help `список реальных данных для замен в шаблоне Tpl
         (на что будем менять по списку TplReplaceFrom)`;
  var TplReplaceTo :Variant[];

  #help `Получаем итоговое содержимое файла rtf`;
  func ToRtf :String;
    Result = TplToRtf(TplReplaceTo);
  end;

  func ToRtf64(Encoding :Variant = '1251') :String;
    Result = TplToRtf64(TplReplaceTo,,,Encoding);
  end;

  proc ToRtfFile(aFile :String; Encoding :Variant = '1251');
    StringToBinaryObject(ToRtf, Encoding).SaveToFile(aFile);
  end;

------------- привязка к записи ------------
  var Internal :Record;

inobject private

end